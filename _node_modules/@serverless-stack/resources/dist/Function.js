"use strict";
/* eslint-disable @typescript-eslint/ban-types*/
// Note: disabling ban-type rule so we don't get an error referencing the class Function
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Function = void 0;
const path_1 = __importDefault(require("path"));
const cdk = __importStar(require("@aws-cdk/core"));
const lambda = __importStar(require("@aws-cdk/aws-lambda"));
const builder_1 = require("./util/builder");
const permission_1 = require("./util/permission");
// A map of supported runtimes and esbuild targets
const runtimeTargetMap = {
    [lambda.Runtime.NODEJS.toString()]: "node12",
    [lambda.Runtime.NODEJS_4_3.toString()]: "node4",
    [lambda.Runtime.NODEJS_6_10.toString()]: "node6",
    [lambda.Runtime.NODEJS_8_10.toString()]: "node8",
    [lambda.Runtime.NODEJS_10_X.toString()]: "node10",
    [lambda.Runtime.NODEJS_12_X.toString()]: "node12",
    [lambda.Runtime.NODEJS_14_X.toString()]: "node14",
};
class Function extends lambda.Function {
    constructor(scope, id, props) {
        const root = scope.node.root;
        // Set defaults
        const handler = props.handler;
        const timeout = props.timeout || 10;
        const srcPath = props.srcPath || ".";
        const memorySize = props.memorySize || 1024;
        const tracing = props.tracing || lambda.Tracing.ACTIVE;
        const runtime = props.runtime || lambda.Runtime.NODEJS_12_X;
        const bundle = props.bundle === undefined ? true : props.bundle;
        // Validate handler
        if (!handler) {
            throw new Error(`No handler defined for the "${id}" Lambda function`);
        }
        if (!bundle && srcPath === ".") {
            throw new Error(`Bundle cannot be disabled for the "${id}" function since the srcPath is set to the project root. Read more here â€” https://github.com/serverless-stack/serverless-stack/issues/78`);
        }
        // Validate NodeJS runtime
        const esbuildTarget = runtimeTargetMap[runtime.toString()];
        if (esbuildTarget === undefined) {
            throw new Error(`The specified runtime is not supported for sst.Function. Only NodeJS runtimes are currently supported.`);
        }
        if (root.local) {
            super(scope, id, Object.assign(Object.assign({}, props), { runtime,
                tracing,
                memorySize, handler: "index.main", timeout: cdk.Duration.seconds(timeout), code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../dist/stub.zip")), environment: Object.assign(Object.assign({}, (props.environment || {})), { SST_DEBUG_SRC_PATH: srcPath, SST_DEBUG_SRC_HANDLER: handler, SST_DEBUG_ENDPOINT: root.debugEndpoint || "" }) }));
        }
        else {
            const { outZip, outHandler } = builder_1.builder({
                bundle,
                srcPath,
                handler,
                target: esbuildTarget,
                buildDir: root.buildDir,
            });
            super(scope, id, Object.assign(Object.assign({}, props), { runtime,
                tracing,
                memorySize, handler: outHandler, code: lambda.Code.fromAsset(outZip), timeout: cdk.Duration.seconds(timeout) }));
        }
        // Enable reusing connections with Keep-Alive for NodeJs Lambda function
        this.addEnvironment("AWS_NODEJS_CONNECTION_REUSE_ENABLED", "1", {
            removeInEdge: true,
        });
        // register Lambda function in app
        root.registerLambdaHandler({
            srcPath,
            handler,
            bundle,
        });
    }
    attachPermissions(permissions) {
        if (this.role) {
            permission_1.attachPermissionsToRole(this.role, permissions);
        }
    }
    static fromDefinition(scope, id, definition) {
        if (typeof definition === "string") {
            return new Function(scope, id, { handler: definition });
        }
        else if (definition instanceof Function) {
            return definition;
        }
        else if (definition instanceof lambda.Function) {
            throw new Error(`Please use sst.Function instead of lambda.Function for the "${id}" Function.`);
        }
        else if (definition.handler !== undefined) {
            return new Function(scope, id, definition);
        }
        throw new Error(`Invalid function definition for the "${id}" Function`);
    }
}
exports.Function = Function;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVuY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvRnVuY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGdEQUFnRDtBQUNoRCx3RkFBd0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFeEYsZ0RBQXdCO0FBRXhCLG1EQUFxQztBQUVyQyw0REFBOEM7QUFHOUMsNENBQXlDO0FBQ3pDLGtEQUF5RTtBQUV6RSxrREFBa0Q7QUFDbEQsTUFBTSxnQkFBZ0IsR0FBRztJQUN2QixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtJQUM1QyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsT0FBTztJQUMvQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsT0FBTztJQUNoRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsT0FBTztJQUNoRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtJQUNqRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtJQUNqRCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsUUFBUTtDQUNsRCxDQUFDO0FBcUVGLE1BQWEsUUFBUyxTQUFRLE1BQU0sQ0FBQyxRQUFRO0lBQzNDLFlBQVksS0FBb0IsRUFBRSxFQUFVLEVBQUUsS0FBb0I7UUFDaEUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFXLENBQUM7UUFFcEMsZUFBZTtRQUNmLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFP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LElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDYixvQ0FBdUIsQ0FBQyxJQUFJLENBQUMsSUFBZ0IsRUFBRSxXQUFXLENBQUMsQ0FBQztTQUM3RDtJQUNILENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUNuQixLQUFvQixFQUNwQixFQUFVLEVBQ1YsVUFBOEI7UUFFOUIsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLEVBQUU7WUFDbEMsT0FBTyxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7U0FDekQ7YUFBTSxJQUFJLFVBQVUsWUFBWSxRQUFRLEVBQUU7WUFDekMsT0FBTyxVQUFVLENBQUM7U0FDbkI7YUFBTSxJQUFJLFVBQVUsWUFBWSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ2hELE1BQU0sSUFBSSxLQUFLLENBQ2IsK0RBQStELEVBQUUsYUFBYSxDQUMvRSxDQUFDO1NBQ0g7YUFBTSxJQUFLLFVBQTRCLENBQUMsT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUM5RCxPQUFPLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDNUM7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzFFLENBQUM7Q0FDRjtBQXpHRCw0QkF5R0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzKi9cbi8vIE5vdGU6IGRpc2FibGluZyBiYW4tdHlwZSBydWxlIHNvIHdlIGRvbid0IGdldCBhbiBlcnJvciByZWZlcmVuY2luZyB0aGUgY2xhc3MgRnVuY3Rpb25cblxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGVzYnVpbGQgZnJvbSBcImVzYnVpbGRcIjtcbmltcG9ydCAqIGFzIGNkayBmcm9tIFwiQGF3cy1jZGsvY29yZVwiO1xuaW1wb3J0ICogYXMgaWFtIGZyb20gXCJAYXdzLWNkay9hd3MtaWFtXCI7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSBcIkBhd3MtY2RrL2F3cy1sYW1iZGFcIjtcblxuaW1wb3J0IHsgQXBwIH0gZnJvbSBcIi4vQXBwXCI7XG5pbXBvcnQgeyBidWlsZGVyIH0gZnJvbSBcIi4vdXRpbC9idWlsZGVyXCI7XG5pbXBvcnQgeyBQZXJtaXNzaW9ucywgYXR0YWNoUGVybWlzc2lvbnNUb1JvbGUgfSBmcm9tIFwiLi91dGlsL3Blcm1pc3Npb25cIjtcblxuLy8gQSBtYXAgb2Ygc3VwcG9ydGVkIHJ1bnRpbWVzIGFuZCBlc2J1aWxkIHRhcmdldHNcbmNvbnN0IHJ1bnRpbWVUYXJnZXRNYXAgPSB7XG4gIFtsYW1iZGEuUnVudGltZS5OT0RFSlMudG9TdHJpbmcoKV06IFwibm9kZTEyXCIsXG4gIFtsYW1iZGEuUnVudGltZS5OT0RFSlNfNF8zLnRvU3RyaW5nKCldOiBcIm5vZGU0XCIsXG4gIFtsYW1iZGEuUnVudGltZS5OT0RFSlNfNl8xMC50b1N0cmluZygpXTogXCJub2RlNlwiLFxuICBbbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzhfMTAudG9TdHJpbmcoKV06IFwibm9kZThcIixcbiAgW2xhbWJkYS5SdW50aW1lLk5PREVKU18xMF9YLnRvU3RyaW5nKCldOiBcIm5vZGUxMFwiLFxuICBbbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzEyX1gudG9TdHJpbmcoKV06IFwibm9kZTEyXCIsXG4gIFtsYW1iZGEuUnVudGltZS5OT0RFSlNfMTRfWC50b1N0cmluZygpXTogXCJub2RlMTRcIixcbn07XG5cbmV4cG9ydCB0eXBlIEhhbmRsZXJQcm9wcyA9IEZ1bmN0aW9uSGFuZGxlclByb3BzO1xuZXhwb3J0IHR5cGUgRnVuY3Rpb25EZWZpbml0aW9uID0gc3RyaW5nIHwgRnVuY3Rpb24gfCBGdW5jdGlvblByb3BzO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uUHJvcHMgZXh0ZW5kcyBPbWl0PGxhbWJkYS5GdW5jdGlvbk9wdGlvbnMsIFwidGltZW91dFwiPiB7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBlbnRyeSBwb2ludCBhbmQgaGFuZGxlciBmdW5jdGlvbi4gT2YgdGhlIGZvcm1hdDpcbiAgICogYC9wYXRoL3RvL2ZpbGUuZnVuY3Rpb25gLlxuICAgKi9cbiAgcmVhZG9ubHkgaGFuZGxlcj86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgZGlyZWN0b3J5IHdoZXJlIHRoZSBlbnRyeSBwb2ludCBpcyBsb2NhdGVkLiBUaGUgbm9kZV9tb2R1bGVzIGluIHRoaXNcbiAgICogZGlyZWN0b3J5IGlzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGJ1bmRsZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byB0aGUgYXBwIGRpcmVjdG9yeS5cbiAgICovXG4gIHJlYWRvbmx5IHNyY1BhdGg/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcnVudGltZSBlbnZpcm9ubWVudC4gT25seSBydW50aW1lcyBvZiB0aGUgTm9kZS5qcyBmYW1pbHkgYXJlXG4gICAqIHN1cHBvcnRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byBOT0RFSlNfMTJfWFxuICAgKi9cbiAgcmVhZG9ubHkgcnVudGltZT86IGxhbWJkYS5SdW50aW1lO1xuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBtZW1vcnkgaW4gTUIgYWxsb2NhdGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIDEwMjRcbiAgICovXG4gIHJlYWRvbmx5IG1lbW9yeVNpemU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgZXhlY3V0aW9uIHRpbWVvdXQgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBudW1iZXJcbiAgICovXG4gIHJlYWRvbmx5IHRpbWVvdXQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBFbmFibGUgQVdTIFgtUmF5IFRyYWNpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gQUNUSVZFXG4gICAqL1xuICByZWFkb25seSB0cmFjaW5nPzogbGFtYmRhLlRyYWNpbmc7XG4gIC8qKlxuICAgKiBEaXNhYmxlIGJ1bmRsaW5nIHdpdGggZXNidWlsZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuICByZWFkb25seSBidW5kbGU/OiBib29sZWFuIHwgRnVuY3Rpb25CdW5kbGVQcm9wcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkhhbmRsZXJQcm9wcyB7XG4gIHJlYWRvbmx5IHNyY1BhdGg6IHN0cmluZztcbiAgcmVhZG9ubHkgaGFuZGxlcjogc3RyaW5nO1xuICByZWFkb25seSBidW5kbGU6IGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZVByb3BzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQnVuZGxlUHJvcHMge1xuICByZWFkb25seSBsb2FkZXI/OiB7IFtleHQ6IHN0cmluZ106IGVzYnVpbGQuTG9hZGVyIH07XG4gIHJlYWRvbmx5IGV4dGVybmFsTW9kdWxlcz86IHN0cmluZ1tdO1xuICByZWFkb25seSBub2RlTW9kdWxlcz86IHN0cmluZ1tdO1xuICByZWFkb25seSBjb3B5RmlsZXM/OiBGdW5jdGlvbkJ1bmRsZUNvcHlGaWxlc1Byb3BzW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25CdW5kbGVDb3B5RmlsZXNQcm9wcyB7XG4gIHJlYWRvbmx5IGZyb206IHN0cmluZztcbiAgcmVhZG9ubHkgdG86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uIGV4dGVuZHMgbGFtYmRhLkZ1bmN0aW9uIHtcbiAgY29uc3RydWN0b3Ioc2NvcGU6IGNkay5Db25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBGdW5jdGlvblByb3BzKSB7XG4gICAgY29uc3Qgcm9vdCA9IHNjb3BlLm5vZGUucm9vdCBhcyBBcHA7XG5cbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICBjb25zdCBoYW5kbGVyID0gcHJvcHMuaGFuZGxlcjtcbiAgICBjb25zdCB0aW1lb3V0ID0gcHJvcHMudGltZW91dCB8fCAxMDtcbiAgICBjb25zdCBzcmNQYXRoID0gcHJvcHMuc3JjUGF0aCB8fCBcIi5cIjtcbiAgICBjb25zdCBtZW1vcnlTaXplID0gcHJvcHMubWVtb3J5U2l6ZSB8fCAxMDI0O1xuICAgIGNvbnN0IHRyYWNpbmcgPSBwcm9wcy50cmFjaW5nIHx8IGxhbWJkYS5UcmFjaW5nLkFDVElWRTtcbiAgICBjb25zdCBydW50aW1lID0gcHJvcHMucnVudGltZSB8fCBsYW1iZGEuUnVudGltZS5OT0RFSlNfMTJfWDtcbiAgICBjb25zdCBidW5kbGUgPSBwcm9wcy5idW5kbGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwcm9wcy5idW5kbGU7XG5cbiAgICAvLyBWYWxpZGF0ZSBoYW5kbGVyXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGhhbmRsZXIgZGVmaW5lZCBmb3IgdGhlIFwiJHtpZH1cIiBMYW1iZGEgZnVuY3Rpb25gKTtcbiAgICB9XG4gICAgaWYgKCFidW5kbGUgJiYgc3JjUGF0aCA9PT0gXCIuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJ1bmRsZSBjYW5ub3QgYmUgZGlzYWJsZWQgZm9yIHRoZSBcIiR7aWR9XCIgZnVuY3Rpb24gc2luY2UgdGhlIHNyY1BhdGggaXMgc2V0IHRvIHRoZSBwcm9qZWN0IHJvb3QuIFJlYWQgbW9yZSBoZXJlIOKAlCBodHRwczovL2dpdGh1Yi5jb20vc2VydmVybGVzcy1zdGFjay9zZXJ2ZXJsZXNzLXN0YWNrL2lzc3Vlcy83OGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgTm9kZUpTIHJ1bnRpbWVcbiAgICBjb25zdCBlc2J1aWxkVGFyZ2V0ID0gcnVudGltZVRhcmdldE1hcFtydW50aW1lLnRvU3RyaW5nKCldO1xuICAgIGlmIChlc2J1aWxkVGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBzcGVjaWZpZWQgcnVudGltZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzc3QuRnVuY3Rpb24uIE9ubHkgTm9kZUpTIHJ1bnRpbWVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHJvb3QubG9jYWwpIHtcbiAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgdHJhY2luZyxcbiAgICAgICAgbWVtb3J5U2l6ZSxcbiAgICAgICAgaGFuZGxlcjogXCJpbmRleC5tYWluXCIsXG4gICAgICAgIHRpbWVvdXQ6IGNkay5EdXJhdGlvbi5zZWNvbmRzKHRpbWVvdXQpLFxuICAgICAgICBjb2RlOiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoXG4gICAgICAgICAgcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgXCIuLi9kaXN0L3N0dWIuemlwXCIpXG4gICAgICAgICksXG4gICAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgICAgLi4uKHByb3BzLmVudmlyb25tZW50IHx8IHt9KSxcbiAgICAgICAgICBTU1RfREVCVUdfU1JDX1BBVEg6IHNyY1BhdGgsXG4gICAgICAgICAgU1NUX0RFQlVHX1NSQ19IQU5ETEVSOiBoYW5kbGVyLFxuICAgICAgICAgIFNTVF9ERUJVR19FTkRQT0lOVDogcm9vdC5kZWJ1Z0VuZHBvaW50IHx8IFwiXCIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBvdXRaaXAsIG91dEhhbmRsZXIgfSA9IGJ1aWxkZXIoe1xuICAgICAgICBidW5kbGUsXG4gICAgICAgIHNyY1BhdGgsXG4gICAgICAgIGhhbmRsZXIsXG4gICAgICAgIHRhcmdldDogZXNidWlsZFRhcmdldCxcbiAgICAgICAgYnVpbGREaXI6IHJvb3QuYnVpbGREaXIsXG4gICAgICB9KTtcbiAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgdHJhY2luZyxcbiAgICAgICAgbWVtb3J5U2l6ZSxcbiAgICAgICAgaGFuZGxlcjogb3V0SGFuZGxlcixcbiAgICAgICAgY29kZTogbGFtYmRhLkNvZGUuZnJvbUFzc2V0KG91dFppcCksXG4gICAgICAgIHRpbWVvdXQ6IGNkay5EdXJhdGlvbi5zZWNvbmRzKHRpbWVvdXQpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIHJldXNpbmcgY29ubmVjdGlvbnMgd2l0aCBLZWVwLUFsaXZlIGZvciBOb2RlSnMgTGFtYmRhIGZ1bmN0aW9uXG4gICAgdGhpcy5hZGRFbnZpcm9ubWVudChcIkFXU19OT0RFSlNfQ09OTkVDVElPTl9SRVVTRV9FTkFCTEVEXCIsIFwiMVwiLCB7XG4gICAgICByZW1vdmVJbkVkZ2U6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyByZWdpc3RlciBMYW1iZGEgZnVuY3Rpb24gaW4gYXBwXG4gICAgcm9vdC5yZWdpc3RlckxhbWJkYUhhbmRsZXIoe1xuICAgICAgc3JjUGF0aCxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBidW5kbGUsXG4gICAgfSBhcyBGdW5jdGlvbkhhbmRsZXJQcm9wcyk7XG4gIH1cblxuICBhdHRhY2hQZXJtaXNzaW9ucyhwZXJtaXNzaW9uczogUGVybWlzc2lvbnMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5yb2xlKSB7XG4gICAgICBhdHRhY2hQZXJtaXNzaW9uc1RvUm9sZSh0aGlzLnJvbGUgYXMgaWFtLlJvbGUsIHBlcm1pc3Npb25zKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZnJvbURlZmluaXRpb24oXG4gICAgc2NvcGU6IGNkay5Db25zdHJ1Y3QsXG4gICAgaWQ6IHN0cmluZyxcbiAgICBkZWZpbml0aW9uOiBGdW5jdGlvbkRlZmluaXRpb25cbiAgKTogRnVuY3Rpb24ge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihzY29wZSwgaWQsIHsgaGFuZGxlcjogZGVmaW5pdGlvbiB9KTtcbiAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfSBlbHNlIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgbGFtYmRhLkZ1bmN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQbGVhc2UgdXNlIHNzdC5GdW5jdGlvbiBpbnN0ZWFkIG9mIGxhbWJkYS5GdW5jdGlvbiBmb3IgdGhlIFwiJHtpZH1cIiBGdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKGRlZmluaXRpb24gYXMgRnVuY3Rpb25Qcm9wcykuaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKHNjb3BlLCBpZCwgZGVmaW5pdGlvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmdW5jdGlvbiBkZWZpbml0aW9uIGZvciB0aGUgXCIke2lkfVwiIEZ1bmN0aW9uYCk7XG4gIH1cbn1cbiJdfQ==