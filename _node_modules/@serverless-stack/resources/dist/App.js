"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.App = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const spawn = __importStar(require("cross-spawn"));
const cdk = __importStar(require("@aws-cdk/core"));
const child_process_1 = require("child_process");
const builder_1 = require("./util/builder");
const appPath = process.cwd();
/**
 * Finds the path to the tsc package executable by converting the file path of:
 * /Users/spongebob/serverless-stack/node_modules/typescript/dist/index.js
 * to:
 * /Users/spongebob/serverless-stack/node_modules/.bin/tsc
 */
function getTsBinPath() {
    const pkg = "typescript";
    const filePath = require.resolve(pkg);
    const matches = filePath.match(/(^.*[/\\]node_modules)[/\\].*$/);
    if (matches === null || !matches[1]) {
        throw new Error(`There was a problem finding ${pkg}`);
    }
    return path.join(matches[1], ".bin", "tsc");
}
/**
 * Uses the current file path and the package name to figure out the path to the
 * CLI. Converts:
 * /Users/spongebob/Sites/serverless-stack/packages/resources/dist/App.js
 * to:
 * /Users/jayair/Sites/serverless-stack/packages/cli
 */
function getSstCliRootPath() {
    const filePath = __dirname;
    const packageName = "resources";
    const packagePath = filePath.slice(0, filePath.lastIndexOf(packageName) + packageName.length);
    return path.join(packagePath, "../cli");
}
function exitWithMessage(message) {
    console.error(message);
    process.exit(1);
}
class App extends cdk.App {
    constructor(deployProps = {}, props = {}) {
        super(props);
        /**
         * Is the app being deployed locally
         */
        this.local = false;
        /**
         * A list of Lambda functions in the app
         */
        this.lambdaHandlers = [];
        this.buildDir = deployProps.buildDir || ".build";
        this.stage = deployProps.stage || "dev";
        this.name = deployProps.name || "my-app";
        this.region = deployProps.region || "us-east-1";
        this.lint = deployProps.lint === false ? false : true;
        if (deployProps.debugEndpoint) {
            this.local = true;
            this.debugEndpoint = deployProps.debugEndpoint;
            this.synthCallback = deployProps.synthCallback;
        }
    }
    logicalPrefixedName(logicalName) {
        const namePrefix = this.name === "" ? "" : `${this.name}-`;
        return `${this.stage}-${namePrefix}${logicalName}`;
    }
    synth(options = {}) {
        for (const child of this.node.children) {
            if (child instanceof cdk.Stack &&
                child.stackName.indexOf(`${this.stage}-`) !== 0) {
                throw new Error(`Stack (${child.stackName}) is not prefixed with the stage. Use sst.Stack or the format {stageName}-${child.stackName}.`);
            }
        }
        const cloudAssembly = super.synth(options);
        // Run lint and type check on handler input files
        // Note: do not need to run in two scenarios:
        //  1. do not need to run while debugging because the Lambda functions are
        //     replaced by stubs and have not been transpiled.
        //  2. do not need to run while running resources tests because .eslint file
        //     does not exist inside .build folder.
        if (!this.local && !this.isJestTest()) {
            this.processInputFiles();
        }
        // Run callback after synth has finished
        if (this.synthCallback) {
            this.synthCallback(this.lambdaHandlers);
        }
        return cloudAssembly;
    }
    isJestTest() {
        // Check the env var set inside test/setup-tests.js
        return process.env.JEST_RESOURCES_TESTS === "enabled";
    }
    registerLambdaHandler(handler) {
        this.lambdaHandlers.push(handler);
    }
    processInputFiles() {
        // Get input files
        const inputFilesBySrcPath = {};
        this.lambdaHandlers.forEach(({ srcPath, handler }) => {
            const metafile = path.join(srcPath, this.buildDir, builder_1.getEsbuildMetafileName(handler));
            const files = this.getInputFilesFromEsbuildMetafile(metafile);
            files.forEach((file) => {
                inputFilesBySrcPath[srcPath] = inputFilesBySrcPath[srcPath] || {};
                inputFilesBySrcPath[srcPath][file] = true;
            });
        });
        // Process each srcPath
        Object.keys(inputFilesBySrcPath).forEach((srcPath) => {
            const inputFiles = Object.keys(inputFilesBySrcPath[srcPath]);
            if (this.lint) {
                this.runLint(srcPath, inputFiles);
            }
            this.runTypeCheck(srcPath, inputFiles);
        });
    }
    getInputFilesFromEsbuildMetafile(file) {
        let metaJson;
        try {
            metaJson = fs.readJsonSync(file);
        }
        catch (e) {
            exitWithMessage("There was a problem reading the esbuild metafile.");
        }
        return Object.keys(metaJson.inputs).map((input) => path.resolve(input));
    }
    runLint(srcPath, inputFiles) {
        inputFiles = inputFiles.filter((file) => file.indexOf("node_modules") === -1 &&
            (file.endsWith(".ts") || file.endsWith(".js")));
        console.log(chalk_1.default.grey("Linting Lambda function source"));
        const response = spawn.sync("node", [
            path.join(appPath, this.buildDir, "eslint.js"),
            process.env.NO_COLOR === "true" ? "--no-color" : "--color",
            ...inputFiles,
        ], 
        // Using the ownPath instead of the appPath because there are cases
        // where npm flattens the dependecies and this casues eslint to be
        // unable to find the parsers and plugins. The ownPath hack seems
        // to fix this issue.
        // https://github.com/serverless-stack/serverless-stack/pull/68
        // Steps to replicate, repo: https://github.com/jayair/sst-eu-example
        // Do `yarn add standard -D` and `sst build`
        { stdio: "inherit", cwd: getSstCliRootPath() });
        if (response.error) {
            console.log(response.error);
            exitWithMessage("There was a problem linting the source.");
        }
        else if (response.stderr) {
            console.log(response.stderr);
            exitWithMessage("There was a problem linting the source.");
        }
        else if (response.status === 1) {
            exitWithMessage("There was a problem linting the source.");
        }
    }
    runTypeCheck(srcPath, inputFiles) {
        inputFiles = inputFiles.filter((file) => file.endsWith(".ts"));
        if (inputFiles.length === 0) {
            return;
        }
        console.log(chalk_1.default.grey("Type checking Lambda function source"));
        const hasTsconfig = fs.existsSync(path.join(srcPath, "tsconfig.json"));
        if (!hasTsconfig) {
            throw new Error(`Cannot find a "tsconfig.json" in the function's srcPath: ${path.resolve(srcPath)}`);
        }
        try {
            const stdout = child_process_1.execSync([
                getTsBinPath(),
                "--pretty",
                process.env.NO_COLOR === "true" ? "false" : "true",
                "--noEmit",
            ].join(" "), { cwd: srcPath });
            const output = stdout.toString();
            if (output.trim() !== "") {
                console.log(output);
            }
        }
        catch (e) {
            console.log(e.stdout.toString());
            exitWithMessage("There was a problem type checking the source.");
        }
    }
}
exports.App = App;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0FwcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0RBQTBCO0FBQzFCLDJDQUE2QjtBQUM3Qiw2Q0FBK0I7QUFDL0IsbURBQXFDO0FBQ3JDLG1EQUFxQztBQUVyQyxpREFBeUM7QUFFekMsNENBQXdEO0FBRXhELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUU5Qjs7Ozs7R0FLRztBQUNILFNBQVMsWUFBWTtJQUNuQixNQUFNLEdBQUcsR0FBRyxZQUFZLENBQUM7SUFDekIsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QyxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7SUFFakUsSUFBSSxPQUFPLEtBQUssSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ25DLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDdkQ7SUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztBQUM5QyxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxpQkFBaUI7SUFDeEIsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDO0lBQzNCLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNoQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUNoQyxDQUFDLEVBQ0QsUUFBUSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUN2RCxDQUFDO0lBRUYsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMs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ckI7Z0JBQ0UsWUFBWSxFQUFFO2dCQUNkLFVBQVU7Z0JBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU07Z0JBQ2xELFVBQVU7YUFDWCxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFDWCxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FDakIsQ0FBQztZQUNGLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNqQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDckI7U0FDRjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDakMsZUFBZSxDQUFDLCtDQUErQyxDQUFDLENBQUM7U0FDbEU7SUFDSCxDQUFDO0NBQ0Y7QUExTkQsa0JBME5DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgKiBhcyBzcGF3biBmcm9tIFwiY3Jvc3Mtc3Bhd25cIjtcbmltcG9ydCAqIGFzIGNkayBmcm9tIFwiQGF3cy1jZGsvY29yZVwiO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSBcIkBhd3MtY2RrL2N4LWFwaVwiO1xuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgRnVuY3Rpb25IYW5kbGVyUHJvcHMgfSBmcm9tIFwiLi9GdW5jdGlvblwiO1xuaW1wb3J0IHsgZ2V0RXNidWlsZE1ldGFmaWxlTmFtZSB9IGZyb20gXCIuL3V0aWwvYnVpbGRlclwiO1xuXG5jb25zdCBhcHBQYXRoID0gcHJvY2Vzcy5jd2QoKTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGF0aCB0byB0aGUgdHNjIHBhY2thZ2UgZXhlY3V0YWJsZSBieSBjb252ZXJ0aW5nIHRoZSBmaWxlIHBhdGggb2Y6XG4gKiAvVXNlcnMvc3BvbmdlYm9iL3NlcnZlcmxlc3Mtc3RhY2svbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQvZGlzdC9pbmRleC5qc1xuICogdG86XG4gKiAvVXNlcnMvc3BvbmdlYm9iL3NlcnZlcmxlc3Mtc3RhY2svbm9kZV9tb2R1bGVzLy5iaW4vdHNjXG4gKi9cbmZ1bmN0aW9uIGdldFRzQmluUGF0aCgpOiBzdHJpbmcge1xuICBjb25zdCBwa2cgPSBcInR5cGVzY3JpcHRcIjtcbiAgY29uc3QgZmlsZVBhdGggPSByZXF1aXJlLnJlc29sdmUocGtnKTtcbiAgY29uc3QgbWF0Y2hlcyA9IGZpbGVQYXRoLm1hdGNoKC8oXi4qWy9cXFxcXW5vZGVfbW9kdWxlcylbL1xcXFxdLiokLyk7XG5cbiAgaWYgKG1hdGNoZXMgPT09IG51bGwgfHwgIW1hdGNoZXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIHdhcyBhIHByb2JsZW0gZmluZGluZyAke3BrZ31gKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLmpvaW4obWF0Y2hlc1sxXSwgXCIuYmluXCIsIFwidHNjXCIpO1xufVxuXG4vKipcbiAqIFVzZXMgdGhlIGN1cnJlbnQgZmlsZSBwYXRoIGFuZCB0aGUgcGFja2FnZSBuYW1lIHRvIGZpZ3VyZSBvdXQgdGhlIHBhdGggdG8gdGhlXG4gKiBDTEkuIENvbnZlcnRzOlxuICogL1VzZXJzL3Nwb25nZWJvYi9TaXRlcy9zZXJ2ZXJsZXNzLXN0YWNrL3BhY2thZ2VzL3Jlc291cmNlcy9kaXN0L0FwcC5qc1xuICogdG86XG4gKiAvVXNlcnMvamF5YWlyL1NpdGVzL3NlcnZlcmxlc3Mtc3RhY2svcGFja2FnZXMvY2xpXG4gKi9cbmZ1bmN0aW9uIGdldFNzdENsaVJvb3RQYXRoKCkge1xuICBjb25zdCBmaWxlUGF0aCA9IF9fZGlybmFtZTtcbiAgY29uc3QgcGFja2FnZU5hbWUgPSBcInJlc291cmNlc1wiO1xuICBjb25zdCBwYWNrYWdlUGF0aCA9IGZpbGVQYXRoLnNsaWNlKFxuICAgIDAsXG4gICAgZmlsZVBhdGgubGFzdEluZGV4T2YocGFja2FnZU5hbWUpICsgcGFja2FnZU5hbWUubGVuZ3RoXG4gICk7XG5cbiAgcmV0dXJuIHBhdGguam9pbihwYWNrYWdlUGF0aCwgXCIuLi9jbGlcIik7XG59XG5cbmZ1bmN0aW9uIGV4aXRXaXRoTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufVxuXG5leHBvcnQgdHlwZSBEZXBsb3lQcm9wcyA9IEFwcERlcGxveVByb3BzO1xuXG4vKipcbiAqIERlcGxveSBwcm9wcyBmb3IgYXBwcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcHBEZXBsb3lQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgYXBwIG5hbWUsIHVzZWQgdG8gcHJlZml4IHN0YWNrcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFnZSB0byBkZXBsb3kgdGhpcyBhcHAgdG8uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gZGV2XG4gICAqL1xuICByZWFkb25seSBzdGFnZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlZ2lvbiB0byBkZXBsb3kgdGhpcyBhcHAgdG8uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gdXMtZWFzdC0xXG4gICAqL1xuICByZWFkb25seSByZWdpb24/OiBzdHJpbmc7XG5cbiAgcmVhZG9ubHkgbGludD86IGJvb2xlYW47XG5cbiAgcmVhZG9ubHkgYnVpbGREaXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBXZWJTb2NrZXRzIGRlYnVnIGVucG9pbnQgdXNlZCBieSBgc3N0IHN0YXJ0YC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IGRlYnVnRW5kcG9pbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBhZnRlciBzeW50aCBjb21wbGV0ZXMsIHVzZWQgYnkgYHNzdCBzdGFydGAuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gdW5kZWZpbmVkXG4gICAqL1xuICByZWFkb25seSBzeW50aENhbGxiYWNrPzogKFxuICAgIGxhbWJkYUhhbmRsZXJzOiBBcnJheTxGdW5jdGlvbkhhbmRsZXJQcm9wcz5cbiAgKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IGNkay5BcHBQcm9wcztcblxuZXhwb3J0IGNsYXNzIEFwcCBleHRlbmRzIGNkay5BcHAge1xuICAvKipcbiAgICogSXMgdGhlIGFwcCBiZWluZyBkZXBsb3llZCBsb2NhbGx5XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbG9jYWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIGFwcCBuYW1lXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhZ2UgdG8gZGVwbG95IHRvXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc3RhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlZ2lvbiB0byBkZXBsb3kgdG9cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSByZWdpb246IHN0cmluZztcblxuICBwdWJsaWMgcmVhZG9ubHkgbGludDogYm9vbGVhbjtcblxuICBwdWJsaWMgcmVhZG9ubHkgYnVpbGREaXI6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxvY2FsIFdlYlNvY2tldHMgZGVidWcgZW5kcG9pbnRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBkZWJ1Z0VuZHBvaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgYWZ0ZXIgc3ludGggY29tcGxldGVzLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBzeW50aENhbGxiYWNrPzogKFxuICAgIGxhbWJkYUhhbmRsZXJzOiBBcnJheTxGdW5jdGlvbkhhbmRsZXJQcm9wcz5cbiAgKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgTGFtYmRhIGZ1bmN0aW9ucyBpbiB0aGUgYXBwXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGxhbWJkYUhhbmRsZXJzOiBBcnJheTxGdW5jdGlvbkhhbmRsZXJQcm9wcz4gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkZXBsb3lQcm9wczogQXBwRGVwbG95UHJvcHMgPSB7fSwgcHJvcHM6IEFwcFByb3BzID0ge30pIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmJ1aWxkRGlyID0gZGVwbG95UHJvcHMuYnVpbGREaXIgfHwgXCIuYnVpbGRcIjtcbiAgICB0aGlzLnN0YWdlID0gZGVwbG95UHJvcHMuc3RhZ2UgfHwgXCJkZXZcIjtcbiAgICB0aGlzLm5hbWUgPSBkZXBsb3lQcm9wcy5uYW1lIHx8IFwibXktYXBwXCI7XG4gICAgdGhpcy5yZWdpb24gPSBkZXBsb3lQcm9wcy5yZWdpb24gfHwgXCJ1cy1lYXN0LTFcIjtcbiAgICB0aGlzLmxpbnQgPSBkZXBsb3lQcm9wcy5saW50ID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcblxuICAgIGlmIChkZXBsb3lQcm9wcy5kZWJ1Z0VuZHBvaW50KSB7XG4gICAgICB0aGlzLmxvY2FsID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVidWdFbmRwb2ludCA9IGRlcGxveVByb3BzLmRlYnVnRW5kcG9pbnQ7XG4gICAgICB0aGlzLnN5bnRoQ2FsbGJhY2sgPSBkZXBsb3lQcm9wcy5zeW50aENhbGxiYWNrO1xuICAgIH1cbiAgfVxuXG4gIGxvZ2ljYWxQcmVmaXhlZE5hbWUobG9naWNhbE5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbmFtZVByZWZpeCA9IHRoaXMubmFtZSA9PT0gXCJcIiA/IFwiXCIgOiBgJHt0aGlzLm5hbWV9LWA7XG4gICAgcmV0dXJuIGAke3RoaXMuc3RhZ2V9LSR7bmFtZVByZWZpeH0ke2xvZ2ljYWxOYW1lfWA7XG4gIH1cblxuICBzeW50aChvcHRpb25zOiBjZGsuU3RhZ2VTeW50aGVzaXNPcHRpb25zID0ge30pOiBjeGFwaS5DbG91ZEFzc2VtYmx5IHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMubm9kZS5jaGlsZHJlbikge1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIGNkay5TdGFjayAmJlxuICAgICAgICBjaGlsZC5zdGFja05hbWUuaW5kZXhPZihgJHt0aGlzLnN0YWdlfS1gKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgU3RhY2sgKCR7Y2hpbGQuc3RhY2tOYW1lfSkgaXMgbm90IHByZWZpeGVkIHdpdGggdGhlIHN0YWdlLiBVc2Ugc3N0LlN0YWNrIG9yIHRoZSBmb3JtYXQge3N0YWdlTmFtZX0tJHtjaGlsZC5zdGFja05hbWV9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2xvdWRBc3NlbWJseSA9IHN1cGVyLnN5bnRoKG9wdGlvbnMpO1xuXG4gICAgLy8gUnVuIGxpbnQgYW5kIHR5cGUgY2hlY2sgb24gaGFuZGxlciBpbnB1dCBmaWxlc1xuICAgIC8vIE5vdGU6IGRvIG5vdCBuZWVkIHRvIHJ1biBpbiB0d28gc2NlbmFyaW9zOlxuICAgIC8vICAxLiBkbyBub3QgbmVlZCB0byBydW4gd2hpbGUgZGVidWdnaW5nIGJlY2F1c2UgdGhlIExhbWJkYSBmdW5jdGlvbnMgYXJlXG4gICAgLy8gICAgIHJlcGxhY2VkIGJ5IHN0dWJzIGFuZCBoYXZlIG5vdCBiZWVuIHRyYW5zcGlsZWQuXG4gICAgLy8gIDIuIGRvIG5vdCBuZWVkIHRvIHJ1biB3aGlsZSBydW5uaW5nIHJlc291cmNlcyB0ZXN0cyBiZWNhdXNlIC5lc2xpbnQgZmlsZVxuICAgIC8vICAgICBkb2VzIG5vdCBleGlzdCBpbnNpZGUgLmJ1aWxkIGZvbGRlci5cbiAgICBpZiAoIXRoaXMubG9jYWwgJiYgIXRoaXMuaXNKZXN0VGVzdCgpKSB7XG4gICAgICB0aGlzLnByb2Nlc3NJbnB1dEZpbGVzKCk7XG4gICAgfVxuXG4gICAgLy8gUnVuIGNhbGxiYWNrIGFmdGVyIHN5bnRoIGhhcyBmaW5pc2hlZFxuICAgIGlmICh0aGlzLnN5bnRoQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMuc3ludGhDYWxsYmFjayh0aGlzLmxhbWJkYUhhbmRsZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvdWRBc3NlbWJseTtcbiAgfVxuXG4gIGlzSmVzdFRlc3QoKTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2sgdGhlIGVudiB2YXIgc2V0IGluc2lkZSB0ZXN0L3NldHVwLXRlc3RzLmpzXG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkpFU1RfUkVTT1VSQ0VTX1RFU1RTID09PSBcImVuYWJsZWRcIjtcbiAgfVxuXG4gIHJlZ2lzdGVyTGFtYmRhSGFuZGxlcihoYW5kbGVyOiBGdW5jdGlvbkhhbmRsZXJQcm9wcyk6IHZvaWQge1xuICAgIHRoaXMubGFtYmRhSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgfVxuXG4gIHByb2Nlc3NJbnB1dEZpbGVzKCk6IHZvaWQge1xuICAgIC8vIEdldCBpbnB1dCBmaWxlc1xuICAgIGNvbnN0IGlucHV0RmlsZXNCeVNyY1BhdGg6IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9O1xuICAgIH0gPSB7fTtcbiAgICB0aGlzLmxhbWJkYUhhbmRsZXJzLmZvckVhY2goKHsgc3JjUGF0aCwgaGFuZGxlciB9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhZmlsZSA9IHBhdGguam9pbihcbiAgICAgICAgc3JjUGF0aCxcbiAgICAgICAgdGhpcy5idWlsZERpcixcbiAgICAgICAgZ2V0RXNidWlsZE1ldGFmaWxlTmFtZShoYW5kbGVyKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRJbnB1dEZpbGVzRnJvbUVzYnVpbGRNZXRhZmlsZShtZXRhZmlsZSk7XG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIGlucHV0RmlsZXNCeVNyY1BhdGhbc3JjUGF0aF0gPSBpbnB1dEZpbGVzQnlTcmNQYXRoW3NyY1BhdGhdIHx8IHt9O1xuICAgICAgICBpbnB1dEZpbGVzQnlTcmNQYXRoW3NyY1BhdGhdW2ZpbGVdID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvY2VzcyBlYWNoIHNyY1BhdGhcbiAgICBPYmplY3Qua2V5cyhpbnB1dEZpbGVzQnlTcmNQYXRoKS5mb3JFYWNoKChzcmNQYXRoKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dEZpbGVzID0gT2JqZWN0LmtleXMoaW5wdXRGaWxlc0J5U3JjUGF0aFtzcmNQYXRoXSk7XG4gICAgICBpZiAodGhpcy5saW50KSB7XG4gICAgICAgIHRoaXMucnVuTGludChzcmNQYXRoLCBpbnB1dEZpbGVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVHlwZUNoZWNrKHNyY1BhdGgsIGlucHV0RmlsZXMpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SW5wdXRGaWxlc0Zyb21Fc2J1aWxkTWV0YWZpbGUoZmlsZTogc3RyaW5nKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgbGV0IG1ldGFKc29uO1xuXG4gICAgdHJ5IHtcbiAgICAgIG1ldGFKc29uID0gZnMucmVhZEpzb25TeW5jKGZpbGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4aXRXaXRoTWVzc2FnZShcIlRoZXJlIHdhcyBhIHByb2JsZW0gcmVhZGluZyB0aGUgZXNidWlsZCBtZXRhZmlsZS5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1ldGFKc29uLmlucHV0cykubWFwKChpbnB1dCkgPT4gcGF0aC5yZXNvbHZlKGlucHV0KSk7XG4gIH1cblxuICBydW5MaW50KHNyY1BhdGg6IHN0cmluZywgaW5wdXRGaWxlczogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuICAgIGlucHV0RmlsZXMgPSBpbnB1dEZpbGVzLmZpbHRlcihcbiAgICAgIChmaWxlOiBzdHJpbmcpID0+XG4gICAgICAgIGZpbGUuaW5kZXhPZihcIm5vZGVfbW9kdWxlc1wiKSA9PT0gLTEgJiZcbiAgICAgICAgKGZpbGUuZW5kc1dpdGgoXCIudHNcIikgfHwgZmlsZS5lbmRzV2l0aChcIi5qc1wiKSlcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coY2hhbGsuZ3JleShcIkxpbnRpbmcgTGFtYmRhIGZ1bmN0aW9uIHNvdXJjZVwiKSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHNwYXduLnN5bmMoXG4gICAgICBcIm5vZGVcIixcbiAgICAgIFtcbiAgICAgICAgcGF0aC5qb2luKGFwcFBhdGgsIHRoaXMuYnVpbGREaXIsIFwiZXNsaW50LmpzXCIpLFxuICAgICAgICBwcm9jZXNzLmVudi5OT19DT0xPUiA9PT0gXCJ0cnVlXCIgPyBcIi0tbm8tY29sb3JcIiA6IFwiLS1jb2xvclwiLFxuICAgICAgICAuLi5pbnB1dEZpbGVzLFxuICAgICAgXSxcbiAgICAgIC8vIFVzaW5nIHRoZSBvd25QYXRoIGluc3RlYWQgb2YgdGhlIGFwcFBhdGggYmVjYXVzZSB0aGVyZSBhcmUgY2FzZXNcbiAgICAgIC8vIHdoZXJlIG5wbSBmbGF0dGVucyB0aGUgZGVwZW5kZWNpZXMgYW5kIHRoaXMgY2FzdWVzIGVzbGludCB0byBiZVxuICAgICAgLy8gdW5hYmxlIHRvIGZpbmQgdGhlIHBhcnNlcnMgYW5kIHBsdWdpbnMuIFRoZSBvd25QYXRoIGhhY2sgc2VlbXNcbiAgICAgIC8vIHRvIGZpeCB0aGlzIGlzc3VlLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlcnZlcmxlc3Mtc3RhY2svc2VydmVybGVzcy1zdGFjay9wdWxsLzY4XG4gICAgICAvLyBTdGVwcyB0byByZXBsaWNhdGUsIHJlcG86IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXlhaXIvc3N0LWV1LWV4YW1wbGVcbiAgICAgIC8vIERvIGB5YXJuIGFkZCBzdGFuZGFyZCAtRGAgYW5kIGBzc3QgYnVpbGRgXG4gICAgICB7IHN0ZGlvOiBcImluaGVyaXRcIiwgY3dkOiBnZXRTc3RDbGlSb290UGF0aCgpIH1cbiAgICApO1xuXG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5lcnJvcik7XG4gICAgICBleGl0V2l0aE1lc3NhZ2UoXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGxpbnRpbmcgdGhlIHNvdXJjZS5cIik7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGRlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLnN0ZGVycik7XG4gICAgICBleGl0V2l0aE1lc3NhZ2UoXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGxpbnRpbmcgdGhlIHNvdXJjZS5cIik7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDEpIHtcbiAgICAgIGV4aXRXaXRoTWVzc2FnZShcIlRoZXJlIHdhcyBhIHByb2JsZW0gbGludGluZyB0aGUgc291cmNlLlwiKTtcbiAgICB9XG4gIH1cblxuICBydW5UeXBlQ2hlY2soc3JjUGF0aDogc3RyaW5nLCBpbnB1dEZpbGVzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgaW5wdXRGaWxlcyA9IGlucHV0RmlsZXMuZmlsdGVyKChmaWxlOiBzdHJpbmcpID0+IGZpbGUuZW5kc1dpdGgoXCIudHNcIikpO1xuXG4gICAgaWYgKGlucHV0RmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coY2hhbGsuZ3JleShcIlR5cGUgY2hlY2tpbmcgTGFtYmRhIGZ1bmN0aW9uIHNvdXJjZVwiKSk7XG5cbiAgICBjb25zdCBoYXNUc2NvbmZpZyA9IGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKHNyY1BhdGgsIFwidHNjb25maWcuanNvblwiKSk7XG5cbiAgICBpZiAoIWhhc1RzY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZmluZCBhIFwidHNjb25maWcuanNvblwiIGluIHRoZSBmdW5jdGlvbidzIHNyY1BhdGg6ICR7cGF0aC5yZXNvbHZlKFxuICAgICAgICAgIHNyY1BhdGhcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYyhcbiAgICAgICAgW1xuICAgICAgICAgIGdldFRzQmluUGF0aCgpLFxuICAgICAgICAgIFwiLS1wcmV0dHlcIixcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT19DT0xPUiA9PT0gXCJ0cnVlXCIgPyBcImZhbHNlXCIgOiBcInRydWVcIixcbiAgICAgICAgICBcIi0tbm9FbWl0XCIsXG4gICAgICAgIF0uam9pbihcIiBcIiksXG4gICAgICAgIHsgY3dkOiBzcmNQYXRoIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBzdGRvdXQudG9TdHJpbmcoKTtcbiAgICAgIGlmIChvdXRwdXQudHJpbSgpICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG91dHB1dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZS5zdGRvdXQudG9TdHJpbmcoKSk7XG4gICAgICBleGl0V2l0aE1lc3NhZ2UoXCJUaGVyZSB3YXMgYSBwcm9ibGVtIHR5cGUgY2hlY2tpbmcgdGhlIHNvdXJjZS5cIik7XG4gICAgfVxuICB9XG59XG4iXX0=