"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = exports.getEsbuildMetafileName = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const zip_local_1 = __importDefault(require("zip-local"));
const esbuild = __importStar(require("esbuild"));
const child_process_1 = require("child_process");
function addExtensionToHandler(handler, extension) {
    return handler.replace(/\.[\w\d]+$/, extension);
}
function getEsbuildMetafileName(handler) {
    const key = handler.replace(/[/.]/g, "-");
    return `.esbuild.${key}.json`;
}
exports.getEsbuildMetafileName = getEsbuildMetafileName;
function getEsbuildExternal(srcPath, bundle) {
    let externals = ["aws-sdk"];
    if (bundle) {
        return [
            ...externals,
            ...(bundle.externalModules || []),
            ...(bundle.nodeModules || []),
        ];
    }
    try {
        const packageJson = fs.readJsonSync(path.join(srcPath, "package.json"));
        externals = Object.keys(Object.assign(Object.assign(Object.assign({}, (packageJson.dependencies || {})), (packageJson.devDependencies || {})), (packageJson.peerDependencies || {})));
    }
    catch (e) {
        console.log(chalk_1.default.grey(`No package.json found in ${srcPath}`));
    }
    return externals;
}
function getEsbuildLoader(bundle) {
    if (bundle) {
        return bundle.loader || {};
    }
    return undefined;
}
function getHandlerFullPosixPath(srcPath, handler) {
    return srcPath === "." ? handler : `${srcPath}/${handler}`;
}
/**
 * Extract versions for a list of modules.
 *
 * First lookup the version in the package.json and then fallback to requiring
 * the module's package.json. The fallback is needed for transitive dependencies.
 */
function extractDependencies(pkgPath, modules) {
    var _a, _b, _c, _d;
    const dependencies = {};
    const pkgJson = fs.readJsonSync(pkgPath);
    const pkgDependencies = Object.assign(Object.assign(Object.assign({}, ((_a = pkgJson.dependencies) !== null && _a !== void 0 ? _a : {})), ((_b = pkgJson.devDependencies) !== null && _b !== void 0 ? _b : {})), ((_c = pkgJson.peerDependencies) !== null && _c !== void 0 ? _c : {}));
    for (const mod of modules) {
        try {
            const version = (_d = pkgDependencies[mod]) !== null && _d !== void 0 ? _d : require(`${mod}/package.json`).version; // eslint-disable-line @typescript-eslint/no-var-requires
            dependencies[mod] = version;
        }
        catch (err) {
            throw new Error(`Cannot extract version for module '${mod}'. Check that it's referenced in your package.json or installed.`);
        }
    }
    return dependencies;
}
function builder(builderProps) {
    const { target, bundle, srcPath, handler, buildDir } = builderProps;
    console.log(chalk_1.default.grey(`Building Lambda function ${getHandlerFullPosixPath(srcPath, handler)}`));
    // Check has tsconfig
    const tsconfig = path.join(srcPath, "tsconfig.json");
    const hasTsconfig = fs.existsSync(tsconfig);
    // Check entry path exists
    let entryPath = path.join(srcPath, addExtensionToHandler(handler, ".ts"));
    if (!fs.existsSync(entryPath)) {
        entryPath = path.join(srcPath, addExtensionToHandler(handler, ".js"));
    }
    if (!fs.existsSync(entryPath)) {
        throw new Error(`Cannot find a handler file at ${entryPath}".`);
    }
    // Four cases:
    //  1. BUNDLE + srcPath ROOT
    //      src       : path/to/file.method
    //      buildPath : .build/hash-$ts
    //      zipPath   : .build/hash-$ts
    //      outZip    : .build/hash-$ts.zip
    //      outHandler: file.method
    //
    //  2. BUNDLE + srcPath NON-ROOT
    //      src       : srcPath/path/to/file.method
    //      buildPath : srcPath/.build/hash-$ts
    //      zipPath   : srcPath/.build/hash-$ts
    //      outZip    : .build/hash-$ts.zip
    //      outHandler: file.method
    //
    //  3. non-BUNDLE + srcPath ROOT
    //      src       : path/to/file.method
    //      buildPath : .build/handlerDir
    //      zipPath   : .
    //
    //     Note: This case is NOT SUPPORTED because we need to zip the app root for each
    //           handler. So after a Lambda's zip is generated, the next Lambda's zip will
    //           contain the previous Lambda's zip inside .build, and the previous Lambda's
    //           zip inside cdk.out.
    //
    //           One solution would be to cherry pick what to zip. For example, zip should
    //           only include the esbuid's output (ie. .js and .js.map files) from the
    //           .build folder.
    //
    //           Also need to clear all .build folders generated from Lambda functions that
    //           has srcPath.
    //
    //  4. non-BUNDLE + srcPath NON-ROOT
    //      src       : srcPath/path/to/file.method
    //      buildPath : srcPath/.build/hash-$ts
    //      zipPath   : srcPath
    //      outZip    : .build/hash-$ts.zip
    //      outHandler: .build/hash-$ts/file.method
    //
    //     Note: place outZip at the app root's .build because entire srcPath is zipped up.
    //           If outZip is srcPath's .build, a Lambda's zip would include zip files from
    //           all the previous Lambdas.
    const appPath = process.cwd();
    const handlerHash = `${getHandlerFullPosixPath(srcPath, handler).replace(/[/.]/g, "-")}-${Date.now()}`;
    const buildPath = path.join(srcPath, buildDir, handlerHash);
    const metafile = path.join(srcPath, buildDir, getEsbuildMetafileName(handler));
    // Transpile
    transpile(entryPath);
    // Package nodeModules
    installNodeModules(srcPath, bundle);
    // Copy files
    copyFiles(bundle);
    // Zip
    let outZip, outHandler;
    if (bundle) {
        outZip = path.join(appPath, buildDir, `${handlerHash}.zip`);
        outHandler = path.basename(handler);
        zip(buildPath, outZip);
    }
    else {
        outZip = path.join(appPath, buildDir, `${handlerHash}.zip`);
        outHandler = `${buildDir}/${handlerHash}/${path.basename(handler)}`;
        zip(srcPath, outZip);
    }
    return { outZip, outHandler };
    function transpile(entryPath) {
        esbuild.buildSync({
            external: getEsbuildExternal(srcPath, bundle),
            loader: getEsbuildLoader(bundle),
            metafile,
            bundle: true,
            format: "cjs",
            sourcemap: true,
            platform: "node",
            target: [target],
            outdir: buildPath,
            entryPoints: [entryPath],
            color: process.env.NO_COLOR !== "true",
            tsconfig: hasTsconfig ? tsconfig : undefined,
        });
    }
    function installNodeModules(srcPath, bundle) {
        // Validate 'nodeModules' is defined in bundle options
        bundle = bundle;
        if (!bundle || !bundle.nodeModules || bundle.nodeModules.length === 0) {
            return;
        }
        // Find 'package.json' at handler's srcPath.
        const pkgPath = path.join(srcPath, "package.json");
        if (!fs.existsSync(pkgPath)) {
            throw new Error(`Cannot find a "package.json" in the function's srcPath: ${path.resolve(srcPath)}`);
        }
        // Determine dependencies versions, lock file and installer
        const dependencies = extractDependencies(pkgPath, bundle.nodeModules);
        let installer = "npm";
        let lockFile;
        if (fs.existsSync(path.join(srcPath, "package-lock.json"))) {
            installer = "npm";
            lockFile = "package-lock.json";
        }
        else if (fs.existsSync(path.join(srcPath, "yarn.lock"))) {
            installer = "yarn";
            lockFile = "yarn.lock";
        }
        // Create dummy package.json, copy lock file if any and then install
        const outputPath = path.join(buildPath, "package.json");
        fs.ensureFileSync(outputPath);
        fs.writeJsonSync(outputPath, { dependencies });
        if (lockFile) {
            fs.copySync(path.join(srcPath, lockFile), path.join(buildPath, lockFile));
        }
        try {
            child_process_1.execSync(`${installer} install`, {
                cwd: buildPath,
                stdio: "pipe",
            });
        }
        catch (e) {
            console.log(e.stdout.toString());
            console.log(e.stderr.toString());
            throw new Error("There was a problem installing nodeModules.");
        }
    }
    function copyFiles(bundle) {
        // Validate 'copyFiles' is defined in bundle options
        bundle = bundle;
        if (!bundle || !bundle.copyFiles || bundle.copyFiles.length === 0) {
            return;
        }
        bundle.copyFiles.forEach(({ from, to }) => {
            const fromPath = path.join(srcPath, from);
            const toPath = path.join(buildPath, to);
            fs.copySync(fromPath, toPath);
        });
    }
    function zip(dir, zipFile) {
        try {
            zip_local_1.default.sync.zip(dir).compress().save(zipFile);
        }
        catch (e) {
            console.log(e);
            throw new Error("There was a problem generating Lambda package.");
        }
        return zipFile;
    }
}
exports.builder = builder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2J1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUEwQjtBQUMxQiwyQ0FBNkI7QUFDN0IsNkNBQStCO0FBQy9CLDBEQUFpQztBQUNqQyxpREFBbUM7QUFDbkMsaURBQXlDO0FBZ0J6QyxTQUFTLHFCQUFxQixDQUFDLE9BQWUsRUFBRSxTQUFpQjtJQUMvRCxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFFRCxTQUFnQixzQkFBc0IsQ0FBQyxPQUFlO0lBQ3BELE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFDLE9BQU8sWUFBWSxHQUFHLE9BQU8sQ0FBQztBQUNoQyxDQUFDO0FBSEQsd0RBR0M7QUFFRCxTQUFTLGtCQUFrQixDQUN6QixPQUFlLEVBQ2YsTUFBcUM7SUFFckMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUU1QixJQUFJLE1BQU0sRUFBRTtRQUNWLE9BQU87WUFDTCxHQUFHLFNBQVM7WUFDWixHQUFHLENBQUUsTUFBOEIsQ0FBQyxlQUFlLElBQUksRUFBRSxDQUFDO1lBQzFELEdBQUcsQ0FBRSxNQUE4QixDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUM7U0FDdkQsQ0FBQztLQUNIO0lBRUQsSUFBSTtRQUNGLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUN4RSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksK0NBQ2xCLENBQUMsV0FBVyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsR0FDaEMsQ0FBQyxXQUFXLENBQUMsZUFB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QU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtZQUN4QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMxQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN4QyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNoQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxTQUFTLEdBQUcsQ0FBQyxHQUFXLEVBQUUsT0FBZTtRQUN2QyxJQUFJO1lBQ0YsbUJBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNqRDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztTQUNuRTtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7QUFDSCxDQUFDO0FBbE1ELDBCQWtNQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0IHppcExvY2FsIGZyb20gXCJ6aXAtbG9jYWxcIjtcbmltcG9ydCAqIGFzIGVzYnVpbGQgZnJvbSBcImVzYnVpbGRcIjtcbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCB7IEZ1bmN0aW9uQnVuZGxlUHJvcHMgfSBmcm9tIFwiLi4vRnVuY3Rpb25cIjtcblxuaW50ZXJmYWNlIEJ1aWxkZXJQcm9wcyB7XG4gIHJlYWRvbmx5IHRhcmdldDogc3RyaW5nO1xuICByZWFkb25seSBzcmNQYXRoOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGhhbmRsZXI6IHN0cmluZztcbiAgcmVhZG9ubHkgYnVuZGxlOiBib29sZWFuIHwgRnVuY3Rpb25CdW5kbGVQcm9wcztcbiAgcmVhZG9ubHkgYnVpbGREaXI6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEJ1aWxkZXJPdXRwdXQge1xuICByZWFkb25seSBvdXRaaXA6IHN0cmluZztcbiAgcmVhZG9ubHkgb3V0SGFuZGxlcjogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBhZGRFeHRlbnNpb25Ub0hhbmRsZXIoaGFuZGxlcjogc3RyaW5nLCBleHRlbnNpb246IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBoYW5kbGVyLnJlcGxhY2UoL1xcLltcXHdcXGRdKyQvLCBleHRlbnNpb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXNidWlsZE1ldGFmaWxlTmFtZShoYW5kbGVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBrZXkgPSBoYW5kbGVyLnJlcGxhY2UoL1svLl0vZywgXCItXCIpO1xuICByZXR1cm4gYC5lc2J1aWxkLiR7a2V5fS5qc29uYDtcbn1cblxuZnVuY3Rpb24gZ2V0RXNidWlsZEV4dGVybmFsKFxuICBzcmNQYXRoOiBzdHJpbmcsXG4gIGJ1bmRsZTogYm9vbGVhbiB8IEZ1bmN0aW9uQnVuZGxlUHJvcHNcbik6IEFycmF5PHN0cmluZz4ge1xuICBsZXQgZXh0ZXJuYWxzID0gW1wiYXdzLXNka1wiXTtcblxuICBpZiAoYnVuZGxlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLmV4dGVybmFscyxcbiAgICAgIC4uLigoYnVuZGxlIGFzIEZ1bmN0aW9uQnVuZGxlUHJvcHMpLmV4dGVybmFsTW9kdWxlcyB8fCBbXSksXG4gICAgICAuLi4oKGJ1bmRsZSBhcyBGdW5jdGlvbkJ1bmRsZVByb3BzKS5ub2RlTW9kdWxlcyB8fCBbXSksXG4gICAgXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcGFja2FnZUpzb24gPSBmcy5yZWFkSnNvblN5bmMocGF0aC5qb2luKHNyY1BhdGgsIFwicGFja2FnZS5qc29uXCIpKTtcbiAgICBleHRlcm5hbHMgPSBPYmplY3Qua2V5cyh7XG4gICAgICAuLi4ocGFja2FnZUpzb24uZGVwZW5kZW5jaWVzIHx8IHt9KSxcbiAgICAgIC4uLihwYWNrYWdlSnNvbi5kZXZEZXBlbmRlbmNpZXMgfHwge30pLFxuICAgICAgLi4uKHBhY2thZ2VKc29uLnBlZXJEZXBlbmRlbmNpZXMgfHwge30pLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5sb2coY2hhbGsuZ3JleShgTm8gcGFja2FnZS5qc29uIGZvdW5kIGluICR7c3JjUGF0aH1gKSk7XG4gIH1cblxuICByZXR1cm4gZXh0ZXJuYWxzO1xufVxuXG5mdW5jdGlvbiBnZXRFc2J1aWxkTG9hZGVyKFxuICBidW5kbGU6IGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZVByb3BzXG4pOiB7IFtleHQ6IHN0cmluZ106IGVzYnVpbGQuTG9hZGVyIH0gfCB1bmRlZmluZWQge1xuICBpZiAoYnVuZGxlKSB7XG4gICAgcmV0dXJuIChidW5kbGUgYXMgRnVuY3Rpb25CdW5kbGVQcm9wcykubG9hZGVyIHx8IHt9O1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEhhbmRsZXJGdWxsUG9zaXhQYXRoKHNyY1BhdGg6IHN0cmluZywgaGFuZGxlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHNyY1BhdGggPT09IFwiLlwiID8gaGFuZGxlciA6IGAke3NyY1BhdGh9LyR7aGFuZGxlcn1gO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdmVyc2lvbnMgZm9yIGEgbGlzdCBvZiBtb2R1bGVzLlxuICpcbiAqIEZpcnN0IGxvb2t1cCB0aGUgdmVyc2lvbiBpbiB0aGUgcGFja2FnZS5qc29uIGFuZCB0aGVuIGZhbGxiYWNrIHRvIHJlcXVpcmluZ1xuICogdGhlIG1vZHVsZSdzIHBhY2thZ2UuanNvbi4gVGhlIGZhbGxiYWNrIGlzIG5lZWRlZCBmb3IgdHJhbnNpdGl2ZSBkZXBlbmRlbmNpZXMuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3REZXBlbmRlbmNpZXMoXG4gIHBrZ1BhdGg6IHN0cmluZyxcbiAgbW9kdWxlczogc3RyaW5nW11cbik6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICBjb25zdCBkZXBlbmRlbmNpZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcblxuICBjb25zdCBwa2dKc29uID0gZnMucmVhZEpzb25TeW5jKHBrZ1BhdGgpO1xuXG4gIGNvbnN0IHBrZ0RlcGVuZGVuY2llcyA9IHtcbiAgICAuLi4ocGtnSnNvbi5kZXBlbmRlbmNpZXMgPz8ge30pLFxuICAgIC4uLihwa2dKc29uLmRldkRlcGVuZGVuY2llcyA/PyB7fSksXG4gICAgLi4uKHBrZ0pzb24ucGVlckRlcGVuZGVuY2llcyA/PyB7fSksXG4gIH07XG5cbiAgZm9yIChjb25zdCBtb2Qgb2YgbW9kdWxlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID1cbiAgICAgICAgcGtnRGVwZW5kZW5jaWVzW21vZF0gPz8gcmVxdWlyZShgJHttb2R9L3BhY2thZ2UuanNvbmApLnZlcnNpb247IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgZGVwZW5kZW5jaWVzW21vZF0gPSB2ZXJzaW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGV4dHJhY3QgdmVyc2lvbiBmb3IgbW9kdWxlICcke21vZH0nLiBDaGVjayB0aGF0IGl0J3MgcmVmZXJlbmNlZCBpbiB5b3VyIHBhY2thZ2UuanNvbiBvciBpbnN0YWxsZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRlcihidWlsZGVyUHJvcHM6IEJ1aWxkZXJQcm9wcyk6IEJ1aWxkZXJPdXRwdXQge1xuICBjb25zdCB7IHRhcmdldCwgYnVuZGxlLCBzcmNQYXRoLCBoYW5kbGVyLCBidWlsZERpciB9ID0gYnVpbGRlclByb3BzO1xuXG4gIGNvbnNvbGUubG9nKFxuICAgIGNoYWxrLmdyZXkoXG4gICAgICBgQnVpbGRpbmcgTGFtYmRhIGZ1bmN0aW9uICR7Z2V0SGFuZGxlckZ1bGxQb3NpeFBhdGgoc3JjUGF0aCwgaGFuZGxlcil9YFxuICAgIClcbiAgKTtcblxuICAvLyBDaGVjayBoYXMgdHNjb25maWdcbiAgY29uc3QgdHNjb25maWcgPSBwYXRoLmpvaW4oc3JjUGF0aCwgXCJ0c2NvbmZpZy5qc29uXCIpO1xuICBjb25zdCBoYXNUc2NvbmZpZyA9IGZzLmV4aXN0c1N5bmModHNjb25maWcpO1xuXG4gIC8vIENoZWNrIGVudHJ5IHBhdGggZXhpc3RzXG4gIGxldCBlbnRyeVBhdGggPSBwYXRoLmpvaW4oc3JjUGF0aCwgYWRkRXh0ZW5zaW9uVG9IYW5kbGVyKGhhbmRsZXIsIFwiLnRzXCIpKTtcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGVudHJ5UGF0aCkpIHtcbiAgICBlbnRyeVBhdGggPSBwYXRoLmpvaW4oc3JjUGF0aCwgYWRkRXh0ZW5zaW9uVG9IYW5kbGVyKGhhbmRsZXIsIFwiLmpzXCIpKTtcbiAgfVxuXG4gIGlmICghZnMuZXhpc3RzU3luYyhlbnRyeVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhIGhhbmRsZXIgZmlsZSBhdCAke2VudHJ5UGF0aH1cIi5gKTtcbiAgfVxuXG4gIC8vIEZvdXIgY2FzZXM6XG4gIC8vICAxLiBCVU5ETEUgKyBzcmNQYXRoIFJPT1RcbiAgLy8gICAgICBzcmMgICAgICAgOiBwYXRoL3RvL2ZpbGUubWV0aG9kXG4gIC8vICAgICAgYnVpbGRQYXRoIDogLmJ1aWxkL2hhc2gtJHRzXG4gIC8vICAgICAgemlwUGF0aCAgIDogLmJ1aWxkL2hhc2gtJHRzXG4gIC8vICAgICAgb3V0WmlwICAgIDogLmJ1aWxkL2hhc2gtJHRzLnppcFxuICAvLyAgICAgIG91dEhhbmRsZXI6IGZpbGUubWV0aG9kXG4gIC8vXG4gIC8vICAyLiBCVU5ETEUgKyBzcmNQYXRoIE5PTi1ST09UXG4gIC8vICAgICAgc3JjICAgICAgIDogc3JjUGF0aC9wYXRoL3RvL2ZpbGUubWV0aG9kXG4gIC8vICAgICAgYnVpbGRQYXRoIDogc3JjUGF0aC8uYnVpbGQvaGFzaC0kdHNcbiAgLy8gICAgICB6aXBQYXRoICAgOiBzcmNQYXRoLy5idWlsZC9oYXNoLSR0c1xuICAvLyAgICAgIG91dFppcCAgICA6IC5idWlsZC9oYXNoLSR0cy56aXBcbiAgLy8gICAgICBvdXRIYW5kbGVyOiBmaWxlLm1ldGhvZFxuICAvL1xuICAvLyAgMy4gbm9uLUJVTkRMRSArIHNyY1BhdGggUk9PVFxuICAvLyAgICAgIHNyYyAgICAgICA6IHBhdGgvdG8vZmlsZS5tZXRob2RcbiAgLy8gICAgICBidWlsZFBhdGggOiAuYnVpbGQvaGFuZGxlckRpclxuICAvLyAgICAgIHppcFBhdGggICA6IC5cbiAgLy9cbiAgLy8gICAgIE5vdGU6IFRoaXMgY2FzZSBpcyBOT1QgU1VQUE9SVEVEIGJlY2F1c2Ugd2UgbmVlZCB0byB6aXAgdGhlIGFwcCByb290IGZvciBlYWNoXG4gIC8vICAgICAgICAgICBoYW5kbGVyLiBTbyBhZnRlciBhIExhbWJkYSdzIHppcCBpcyBnZW5lcmF0ZWQsIHRoZSBuZXh0IExhbWJkYSdzIHppcCB3aWxsXG4gIC8vICAgICAgICAgICBjb250YWluIHRoZSBwcmV2aW91cyBMYW1iZGEncyB6aXAgaW5zaWRlIC5idWlsZCwgYW5kIHRoZSBwcmV2aW91cyBMYW1iZGEnc1xuICAvLyAgICAgICAgICAgemlwIGluc2lkZSBjZGsub3V0LlxuICAvL1xuICAvLyAgICAgICAgICAgT25lIHNvbHV0aW9uIHdvdWxkIGJlIHRvIGNoZXJyeSBwaWNrIHdoYXQgdG8gemlwLiBGb3IgZXhhbXBsZSwgemlwIHNob3VsZFxuICAvLyAgICAgICAgICAgb25seSBpbmNsdWRlIHRoZSBlc2J1aWQncyBvdXRwdXQgKGllLiAuanMgYW5kIC5qcy5tYXAgZmlsZXMpIGZyb20gdGhlXG4gIC8vICAgICAgICAgICAuYnVpbGQgZm9sZGVyLlxuICAvL1xuICAvLyAgICAgICAgICAgQWxzbyBuZWVkIHRvIGNsZWFyIGFsbCAuYnVpbGQgZm9sZGVycyBnZW5lcmF0ZWQgZnJvbSBMYW1iZGEgZnVuY3Rpb25zIHRoYXRcbiAgLy8gICAgICAgICAgIGhhcyBzcmNQYXRoLlxuICAvL1xuICAvLyAgNC4gbm9uLUJVTkRMRSArIHNyY1BhdGggTk9OLVJPT1RcbiAgLy8gICAgICBzcmMgICAgICAgOiBzcmNQYXRoL3BhdGgvdG8vZmlsZS5tZXRob2RcbiAgLy8gICAgICBidWlsZFBhdGggOiBzcmNQYXRoLy5idWlsZC9oYXNoLSR0c1xuICAvLyAgICAgIHppcFBhdGggICA6IHNyY1BhdGhcbiAgLy8gICAgICBvdXRaaXAgICAgOiAuYnVpbGQvaGFzaC0kdHMuemlwXG4gIC8vICAgICAgb3V0SGFuZGxlcjogLmJ1aWxkL2hhc2gtJHRzL2ZpbGUubWV0aG9kXG4gIC8vXG4gIC8vICAgICBOb3RlOiBwbGFjZSBvdXRaaXAgYXQgdGhlIGFwcCByb290J3MgLmJ1aWxkIGJlY2F1c2UgZW50aXJlIHNyY1BhdGggaXMgemlwcGVkIHVwLlxuICAvLyAgICAgICAgICAgSWYgb3V0WmlwIGlzIHNyY1BhdGgncyAuYnVpbGQsIGEgTGFtYmRhJ3MgemlwIHdvdWxkIGluY2x1ZGUgemlwIGZpbGVzIGZyb21cbiAgLy8gICAgICAgICAgIGFsbCB0aGUgcHJldmlvdXMgTGFtYmRhcy5cblxuICBjb25zdCBhcHBQYXRoID0gcHJvY2Vzcy5jd2QoKTtcbiAgY29uc3QgaGFuZGxlckhhc2ggPSBgJHtnZXRIYW5kbGVyRnVsbFBvc2l4UGF0aChzcmNQYXRoLCBoYW5kbGVyKS5yZXBsYWNlKFxuICAgIC9bLy5dL2csXG4gICAgXCItXCJcbiAgKX0tJHtEYXRlLm5vdygpfWA7XG4gIGNvbnN0IGJ1aWxkUGF0aCA9IHBhdGguam9pbihzcmNQYXRoLCBidWlsZERpciwgaGFuZGxlckhhc2gpO1xuICBjb25zdCBtZXRhZmlsZSA9IHBhdGguam9pbihcbiAgICBzcmNQYXRoLFxuICAgIGJ1aWxkRGlyLFxuICAgIGdldEVzYnVpbGRNZXRhZmlsZU5hbWUoaGFuZGxlcilcbiAgKTtcblxuICAvLyBUcmFuc3BpbGVcbiAgdHJhbnNwaWxlKGVudHJ5UGF0aCk7XG5cbiAgLy8gUGFja2FnZSBub2RlTW9kdWxlc1xuICBpbnN0YWxsTm9kZU1vZHVsZXMoc3JjUGF0aCwgYnVuZGxlKTtcblxuICAvLyBDb3B5IGZpbGVzXG4gIGNvcHlGaWxlcyhidW5kbGUpO1xuXG4gIC8vIFppcFxuICBsZXQgb3V0WmlwLCBvdXRIYW5kbGVyO1xuICBpZiAoYnVuZGxlKSB7XG4gICAgb3V0WmlwID0gcGF0aC5qb2luKGFwcFBhdGgsIGJ1aWxkRGlyLCBgJHtoYW5kbGVySGFzaH0uemlwYCk7XG4gICAgb3V0SGFuZGxlciA9IHBhdGguYmFzZW5hbWUoaGFuZGxlcik7XG4gICAgemlwKGJ1aWxkUGF0aCwgb3V0WmlwKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRaaXAgPSBwYXRoLmpvaW4oYXBwUGF0aCwgYnVpbGREaXIsIGAke2hhbmRsZXJIYXNofS56aXBgKTtcbiAgICBvdXRIYW5kbGVyID0gYCR7YnVpbGREaXJ9LyR7aGFuZGxlckhhc2h9LyR7cGF0aC5iYXNlbmFtZShoYW5kbGVyKX1gO1xuICAgIHppcChzcmNQYXRoLCBvdXRaaXApO1xuICB9XG5cbiAgcmV0dXJuIHsgb3V0WmlwLCBvdXRIYW5kbGVyIH07XG5cbiAgZnVuY3Rpb24gdHJhbnNwaWxlKGVudHJ5UGF0aDogc3RyaW5nKSB7XG4gICAgZXNidWlsZC5idWlsZFN5bmMoe1xuICAgICAgZXh0ZXJuYWw6IGdldEVzYnVpbGRFeHRlcm5hbChzcmNQYXRoLCBidW5kbGUpLFxuICAgICAgbG9hZGVyOiBnZXRFc2J1aWxkTG9hZGVyKGJ1bmRsZSksXG4gICAgICBtZXRhZmlsZSxcbiAgICAgIGJ1bmRsZTogdHJ1ZSxcbiAgICAgIGZvcm1hdDogXCJjanNcIixcbiAgICAgIHNvdXJjZW1hcDogdHJ1ZSxcbiAgICAgIHBsYXRmb3JtOiBcIm5vZGVcIixcbiAgICAgIHRhcmdldDogW3RhcmdldF0sXG4gICAgICBvdXRkaXI6IGJ1aWxkUGF0aCxcbiAgICAgIGVudHJ5UG9pbnRzOiBbZW50cnlQYXRoXSxcbiAgICAgIGNvbG9yOiBwcm9jZXNzLmVudi5OT19DT0xPUiAhPT0gXCJ0cnVlXCIsXG4gICAgICB0c2NvbmZpZzogaGFzVHNjb25maWcgPyB0c2NvbmZpZyA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxOb2RlTW9kdWxlcyhcbiAgICBzcmNQYXRoOiBzdHJpbmcsXG4gICAgYnVuZGxlOiBib29sZWFuIHwgRnVuY3Rpb25CdW5kbGVQcm9wc1xuICApIHtcbiAgICAvLyBWYWxpZGF0ZSAnbm9kZU1vZHVsZXMnIGlzIGRlZmluZWQgaW4gYnVuZGxlIG9wdGlvbnNcbiAgICBidW5kbGUgPSBidW5kbGUgYXMgRnVuY3Rpb25CdW5kbGVQcm9wcztcbiAgICBpZiAoIWJ1bmRsZSB8fCAhYnVuZGxlLm5vZGVNb2R1bGVzIHx8IGJ1bmRsZS5ub2RlTW9kdWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaW5kICdwYWNrYWdlLmpzb24nIGF0IGhhbmRsZXIncyBzcmNQYXRoLlxuICAgIGNvbnN0IHBrZ1BhdGggPSBwYXRoLmpvaW4oc3JjUGF0aCwgXCJwYWNrYWdlLmpzb25cIik7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHBrZ1BhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZmluZCBhIFwicGFja2FnZS5qc29uXCIgaW4gdGhlIGZ1bmN0aW9uJ3Mgc3JjUGF0aDogJHtwYXRoLnJlc29sdmUoXG4gICAgICAgICAgc3JjUGF0aFxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGRlcGVuZGVuY2llcyB2ZXJzaW9ucywgbG9jayBmaWxlIGFuZCBpbnN0YWxsZXJcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBleHRyYWN0RGVwZW5kZW5jaWVzKHBrZ1BhdGgsIGJ1bmRsZS5ub2RlTW9kdWxlcyk7XG4gICAgbGV0IGluc3RhbGxlciA9IFwibnBtXCI7XG4gICAgbGV0IGxvY2tGaWxlO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGguam9pbihzcmNQYXRoLCBcInBhY2thZ2UtbG9jay5qc29uXCIpKSkge1xuICAgICAgaW5zdGFsbGVyID0gXCJucG1cIjtcbiAgICAgIGxvY2tGaWxlID0gXCJwYWNrYWdlLWxvY2suanNvblwiO1xuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4oc3JjUGF0aCwgXCJ5YXJuLmxvY2tcIikpKSB7XG4gICAgICBpbnN0YWxsZXIgPSBcInlhcm5cIjtcbiAgICAgIGxvY2tGaWxlID0gXCJ5YXJuLmxvY2tcIjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgZHVtbXkgcGFja2FnZS5qc29uLCBjb3B5IGxvY2sgZmlsZSBpZiBhbnkgYW5kIHRoZW4gaW5zdGFsbFxuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4oYnVpbGRQYXRoLCBcInBhY2thZ2UuanNvblwiKTtcbiAgICBmcy5lbnN1cmVGaWxlU3luYyhvdXRwdXRQYXRoKTtcbiAgICBmcy53cml0ZUpzb25TeW5jKG91dHB1dFBhdGgsIHsgZGVwZW5kZW5jaWVzIH0pO1xuICAgIGlmIChsb2NrRmlsZSkge1xuICAgICAgZnMuY29weVN5bmMocGF0aC5qb2luKHNyY1BhdGgsIGxvY2tGaWxlKSwgcGF0aC5qb2luKGJ1aWxkUGF0aCwgbG9ja0ZpbGUpKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZXhlY1N5bmMoYCR7aW5zdGFsbGVyfSBpbnN0YWxsYCwge1xuICAgICAgICBjd2Q6IGJ1aWxkUGF0aCxcbiAgICAgICAgc3RkaW86IFwicGlwZVwiLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZS5zdGRvdXQudG9TdHJpbmcoKSk7XG4gICAgICBjb25zb2xlLmxvZyhlLnN0ZGVyci50b1N0cmluZygpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhIHByb2JsZW0gaW5zdGFsbGluZyBub2RlTW9kdWxlcy5cIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29weUZpbGVzKGJ1bmRsZTogYm9vbGVhbiB8IEZ1bmN0aW9uQnVuZGxlUHJvcHMpIHtcbiAgICAvLyBWYWxpZGF0ZSAnY29weUZpbGVzJyBpcyBkZWZpbmVkIGluIGJ1bmRsZSBvcHRpb25zXG4gICAgYnVuZGxlID0gYnVuZGxlIGFzIEZ1bmN0aW9uQnVuZGxlUHJvcHM7XG4gICAgaWYgKCFidW5kbGUgfHwgIWJ1bmRsZS5jb3B5RmlsZXMgfHwgYnVuZGxlLmNvcHlGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBidW5kbGUuY29weUZpbGVzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgY29uc3QgZnJvbVBhdGggPSBwYXRoLmpvaW4oc3JjUGF0aCwgZnJvbSk7XG4gICAgICBjb25zdCB0b1BhdGggPSBwYXRoLmpvaW4oYnVpbGRQYXRoLCB0byk7XG4gICAgICBmcy5jb3B5U3luYyhmcm9tUGF0aCwgdG9QYXRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHppcChkaXI6IHN0cmluZywgemlwRmlsZTogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHppcExvY2FsLnN5bmMuemlwKGRpcikuY29tcHJlc3MoKS5zYXZlKHppcEZpbGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGEgcHJvYmxlbSBnZW5lcmF0aW5nIExhbWJkYSBwYWNrYWdlLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZTtcbiAgfVxufVxuIl19